<?php
declare(strict_types=1);
namespace SourceBroker\T3api\Service;

use DateTime;
use Doctrine\Common\Annotations\AnnotationException;
use Doctrine\Common\Annotations\AnnotationReader;
use ReflectionClass;
use ReflectionException;
use ReflectionMethod;
use ReflectionProperty;
use RuntimeException;
use SourceBroker\T3api\Annotation\Serializer\Groups;
use SourceBroker\T3api\Annotation\Serializer\Type\TypeInterface;
use SourceBroker\T3api\Annotation\Serializer\VirtualProperty;
use Symfony\Component\Yaml\Yaml;
use TYPO3\CMS\Extbase\Persistence\ObjectStorage;
use TYPO3\CMS\Extbase\Reflection\DocCommentParser;

/**
 * Class SerializerMetadataService
 */
class SerializerMetadataService
{
    /**
     * @param string $entity
     *
     * @throws ReflectionException
     * @throws AnnotationException
     */
    public static function generateAutoloadForEntity(string $entity): void
    {
        $generatedMetadataFile = SerializerService::getAutogeneratedMetadataDirectory() . '/'
            . str_replace('\\', '.', $entity) . '.yml';

        file_put_contents($generatedMetadataFile, Yaml::dump(self::getForEntity($entity), 99));
    }

    /**
     * @param string $entity
     *
     * @throws ReflectionException
     * @throws AnnotationException
     * @return array
     */
    protected static function getForEntity(string $entity): array
    {
        $reflectionClass = new ReflectionClass($entity);
        $annotationReader = new AnnotationReader();

        return [
            $entity => [
                'properties' => self::getProperties($reflectionClass, $annotationReader),
                'virtual_properties' => self::getVirtualProperties($reflectionClass, $annotationReader),
            ],
        ];
    }

    /**
     * @param ReflectionClass $reflectionClass
     * @param AnnotationReader $annotationReader
     *
     * @return array
     */
    protected static function getProperties(ReflectionClass $reflectionClass, AnnotationReader $annotationReader): array
    {
        $docCommentParser = new DocCommentParser(true);
        $properties = [];

        /** @var ReflectionProperty $property */
        foreach ($reflectionClass->getProperties() as $reflectionProperty) {
            $docCommentParser->parseDocComment($reflectionProperty->getDocComment());
            $type = $docCommentParser->getTagValues('var')[0];

            if (empty($type)) {
                throw new RuntimeException(
                    sprintf(
                        '`@var` annotation missing in property %s',
                        $reflectionClass->getName() . '::' . $reflectionProperty->getName()
                    ),
                    1570723476311
                );
            }

            $properties[$reflectionProperty->getName()] = self::getPropertyMetadataFromAnnotations(
                $annotationReader->getPropertyAnnotations($reflectionProperty)
            );
            if (empty($properties[$reflectionProperty->getName()]['type'])) {
                $properties[$reflectionProperty->getName()]['type'] = self::parsePropertyType($type);
            }
        }

        return $properties;
    }

    /**
     * @param ReflectionClass $reflectionClass
     * @param AnnotationReader $annotationReader
     *
     * @return array
     */
    protected static function getVirtualProperties(
        ReflectionClass $reflectionClass,
        AnnotationReader $annotationReader
    ): array {
        $virtualProperties = [];

        /** @var ReflectionMethod $property */
        foreach ($reflectionClass->getMethods(ReflectionMethod::IS_PUBLIC) as $reflectionMethod) {
            /** @var VirtualProperty $virtualProperty */
            $virtualProperty = $annotationReader->getMethodAnnotation($reflectionMethod, VirtualProperty::class);

            if (!$virtualProperty) {
                continue;
            }

            if ($virtualProperty->name) {
                $propertyName = $virtualProperty->name;
            } elseif (strpos($reflectionMethod->getName(), 'is') === 0) {
                $propertyName = lcfirst(substr($reflectionMethod->getName(), 2));
            } elseif (strpos($reflectionMethod->getName(), 'get') === 0) {
                $propertyName = lcfirst(substr($reflectionMethod->getName(), 3));
            } elseif (strpos($reflectionMethod->getName(), 'has') === 0) {
                $propertyName = lcfirst(substr($reflectionMethod->getName(), 3));
            } else {
                $propertyName = $reflectionMethod->getName();
            }

            $virtualProperties[$reflectionMethod->getName()] = self::getPropertyMetadataFromAnnotations(
                $annotationReader->getMethodAnnotations($reflectionMethod)
            );
            $virtualProperties[$reflectionMethod->getName()]['name'] = $propertyName;
            $virtualProperties[$reflectionMethod->getName()]['serialized_name'] = $propertyName;
        }

        return $virtualProperties;
    }

    /**
     * @param string $type
     *
     * @return string
     * @todo 591 add tests
     */
    protected static function parsePropertyType(string $type)
    {
        $type = trim(explode(' ', trim($type))[0]);

        if (is_a($type, DateTime::class, true)) {
            return sprintf('DateTime<"%s">', DateTime::ATOM);
        } elseif (class_exists($type)) {
            return ltrim($type, '\\');
        } elseif (in_array($type, ['string', 'int', 'integer', 'boolean', 'bool', 'double', 'float'])) {
            return $type;
        } elseif (strpos($type, '<') !== false) {
            $collectionType = trim(explode('<', $type)[0]);
            $itemsType = trim(explode('<', $type)[1], '> ');

            if (is_a($collectionType, ObjectStorage::class, true)) {
                return sprintf('%s<%s>', ObjectStorage::class, ltrim($itemsType, '\\'));
            }

            // @todo 591 surely it does not resolve all cases
        }

        return $type;
    }

    /**
     * @param object[] $annotations
     *
     * @return array
     */
    protected static function getPropertyMetadataFromAnnotations(array $annotations): array
    {
        $metadata = [];

        foreach ($annotations as $annotation) {
            if ($annotation instanceof Groups) {
                $metadata['groups'] = $annotation->groups;
            } elseif ($annotation instanceof TypeInterface) {
                $metadata['type'] = $annotation->getName();

                if (!empty($annotation->getParams())) {
                    $metadata['type'] .= '<"' . implode('","', $annotation->getParams()) . '">';
                }
            }

            // @todo 591 add support to rest of t3api annotations
        }

        return $metadata;
    }
}
